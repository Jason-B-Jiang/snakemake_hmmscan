mutate(yeast_domain_archs = get_ortholog_domain_arch(orthogroup,
yeast_ortholog,
orthogroup_domain_archs),
species_domain_archs = get_ortholog_domain_arch(orthogroup,
species_ortholog,
orthogroup_domain_archs)) %>%
ungroup() %>%
separate(yeast_domain_archs, c('yeast_domain_arch',
'yeast_domain_arch_clan',
'yeast_domain_bounds'), sep = ' ::: ') %>%
separate(species_domain_archs, c('species_domain_arch',
'species_domain_arch_clan',
'species_domain_bounds'), sep = ' ::: ') %>%
rowwise() %>%
mutate(aligned_ortholog_domain_archs = align_domain_archs(species_domain_arch,
species_domain_arch_clan,
yeast_domain_arch,
yeast_domain_arch_clan),
lost_doms = get_lost_doms(aligned_ortholog_domain_archs,
species_domain_arch,
yeast_domain_arch),
gained_doms = get_gained_doms(aligned_ortholog_domain_archs,
species_domain_arch,
yeast_domain_arch),
swapped_doms = get_swapped_doms(aligned_ortholog_domain_archs,
fam_to_clan)) %>%
ungroup() %>%
mutate(lost_doms_len = get_lost_doms_len(aligned_ortholog_domain_archs,
yeast_domain_bounds,
species_domain_arch),
ortholog_short_enough_for_dom_loss =
species_len <= (yeast_len - 0.85 * lost_doms_len))
)
}
get_ortholog_domain_arch <- function(orthogroup, ortholog, orthogroup_domain_archs) {
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
if (is_null(orthogroup_domain_archs[[orthogroup]]) |
is_null(orthogroup_domain_archs[[orthogroup]][[ortholog]])) {
return(NA)
}
return(str_c(
orthogroup_domain_archs[[orthogroup]][[ortholog]]$domain_arch,
orthogroup_domain_archs[[orthogroup]][[ortholog]]$domain_arch_clan,
orthogroup_domain_archs[[orthogroup]][[ortholog]]$domain_bounds,
sep = ' ::: '
))
}
align_domain_archs <- function(DA_1, DA_1_clans, DA_2, DA_2_clans) {
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
if (any(is.na(DA_1), is.na(DA_2))) {
return(NA)
}
DA_1 <- str_split(DA_1, '; ')[[1]]
DA_1_clans <- str_split(DA_1_clans, '; ')[[1]]
DA_2 <- str_split(DA_2, '; ')[[1]]
DA_2_clans <- str_split(DA_2_clans, '; ')[[1]]
# since we are aligning domain architectures using their domain clans, get
# a list mapping each clan to a unique letter representation
clans_to_letters <- get_clan_letters(unique(c(DA_1_clans, DA_2_clans)))
# create string representations of each domain architecture using the clan to
# letter mappings, for alignment
DA_1_str = str_c(sapply(DA_1_clans, function(x) {clans_to_letters[[x]]}),
collapse = '')
DA_2_str = str_c(sapply(DA_2_clans, function(x) {clans_to_letters[[x]]}),
collapse = '')
# align domain architectures using their string representations
aligned_DA <- needles(DA_1_str, DA_2_str, params = NW_PARAMS)
# return formatted string of domain architecture alignments, with original
# domains replacing the letter representations in the alignments
return(
str_c(
format_alignment_str(aligned_DA$align1, DA_1),
format_alignment_str(aligned_DA$align2, DA_2),
sep = '; '
)
)
}
get_clan_letters <- function(clans) {
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
clans_to_letters <- lapply(as.list(1 : length(clans)), function(i) {LETTERS[i]})
names(clans_to_letters) <- clans
return(clans_to_letters)
}
format_alignment_str <- function(aln_str, domain_arch) {
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
aln_str <- str_split(aln_str, '')[[1]]
i = 1
for (j in 1 : length(aln_str)) {
if (aln_str[j] != '*') {
aln_str[j] <- domain_arch[i]
i <- i + 1
}
}
return(str_c(aln_str, collapse = ' -> '))
}
get_lost_doms <- function(aligned_DA, DA_1, DA_2) {
# ---------------------------------------------------------------------------
# Return domains from the first ortholog domain architecture, DA_1, that have
# been lost from the second ortholog domain architecture, DA_2, using their
# aligned domain architectures.
#
# Args:
#   aligned_DA: aligned domain architectures for both orthologs
#
#   DA_1: domain architecture for first ortholog
#
#   DA_2: domain architecture for second ortholog.
#
# ---------------------------------------------------------------------------
# no domain assignments for first ortholog, so just treat all domains from the
# second ortholog as 'lost' domains
if (is.na(DA_1)) {
return(DA_2)
# no domain assignments for second ortholog, so no domain losses possible for
# ortholog
} else if (is.na(DA_2)) {
return(NA)
}
aligned_DA <- str_split(aligned_DA, '; ')[[1]]
aligned_DA_1 <- str_split(aligned_DA[1], ' -> ')[[1]]
aligned_DA_2 <- str_split(aligned_DA[2], ' -> ')[[1]]
lost_doms <- aligned_DA_2[which(aligned_DA_1 == '*')]
return(ifelse(length(lost_doms) > 0,
str_c(lost_doms, collapse = '; '),
NA))
}
get_gained_doms <- function(aligned_DA, DA_1, DA_2) {
# ---------------------------------------------------------------------------
# Return domains from the first ortholog domain architecture, DA_1, that have
# been gained from the second ortholog domain architecture, DA_2, using their
# aligned domain architectures.
#
# Args:
#   aligned_DA: aligned domain architectures for both orthologs
#
#   DA_1: domain architecture for first ortholog
#
#   DA_2: domain architecture for second ortholog
#
# ---------------------------------------------------------------------------
# if no domain assignments for first ortholog, then no domain gains possible
# for first ortholog
if (is.na(DA_1)) {
return(NA)
# if no domain assignments for second ortholog, then consider all domains in
# first ortholog to be gained domains
} else if (is.na(DA_2)) {
return(DA_1)
}
aligned_DA <- str_split(aligned_DA, '; ')[[1]]
aligned_DA_1 <- str_split(aligned_DA[1], ' -> ')[[1]]
aligned_DA_2 <- str_split(aligned_DA[2], ' -> ')[[1]]
gained_doms <- aligned_DA_1[which(aligned_DA_2 == '*')]
return(ifelse(length(gained_doms) > 0,
str_c(gained_doms, collapse = '; '),
NA))
}
get_swapped_doms <- function(aligned_DA, fam_to_clan) {
# ---------------------------------------------------------------------------
# Return domains from the first ortholog domain architecture, DA_1, that have
# been swapped from the second ortholog domain architecture, DA_2, using their
# aligned domain architectures.
#
# Args:
#   aligned_DA: aligned domain architectures for both orthologs
#
#   DA_1: domain architecture for first ortholog
#
#   DA_2: domain architecture for second ortholog
#
# ---------------------------------------------------------------------------
# if no domain assignments for either ortholog, then no domain swapping is
# possible between the two orthologs
if (is.na(aligned_DA)) {
return(NA)
}
aligned_DA <- str_split(aligned_DA, '; ')[[1]]
# convert domains in domain architectures back to their clans
# domain swap = domain of different CLAN in ortholog 1 than in ortholog 2
aligned_DA_1 <- str_split(aligned_DA[1], ' -> ')[[1]]
aligned_DA_1_clans <- sapply(aligned_DA_1,
function(x) {ifelse(x != '*',
fam_to_clan[[x]],
x)})
aligned_DA_2 <- str_split(aligned_DA[2], ' -> ')[[1]]
aligned_DA_2_clans <- sapply(aligned_DA_2,
function(x) {ifelse(x != '*',
fam_to_clan[[x]],
x)})
swapped_doms_idx <- which(aligned_DA_1_clans != aligned_DA_2_clans &
aligned_DA_1_clans != '*' &
aligned_DA_2_clans != '*')
swapped_doms <- map2_chr(aligned_DA_1[swapped_doms_idx],
aligned_DA_2[swapped_doms_idx],
function(x, y) {str_c(x, y, sep = ' -> ')})
return(ifelse(length(swapped_doms) > 0,
str_c(swapped_doms, collapse = '; '),
NA))
}
################################################################################
### Helper functions for verifying domain losses heuristically
get_lost_doms_len <- Vectorize(function(aligned_DA, yeast_domain_bounds,
species_domain_arch) {
# ---------------------------------------------------------------------------
# Docstring goes here.
# ---------------------------------------------------------------------------
# if no domain assignments for this species ortholog, return the length of
# all domains in the yeast ortholog
if (is.na(species_domain_arch)) {
lost_dom_lens <- str_split(yeast_domain_bounds, '; ')[[1]]
} else {
# otherwise, get length of all lost domains only from the yeast ortholog
species_DA <- str_split(str_split(aligned_DA, '; ')[[1]][1], ' -> ')[[1]]
lost_dom_posns <- which(species_DA == '*')
if (length(lost_dom_posns) == 0) {
# no lost domains in this species ortholog, so return NA
return(NA)
}
lost_dom_lens <- str_split(yeast_domain_bounds, '; ')[[1]][lost_dom_posns]
}
return(sum(sapply(lost_dom_lens, function(x) {get_domain_len(x)})))
}, vectorize.args = c('aligned_DA', 'yeast_domain_bounds', 'species_domain_arch'))
get_domain_len <- Vectorize(function(dom_bounds) {
# ---------------------------------------------------------------------------
# Docstring goes here.
# ---------------------------------------------------------------------------
dom_fragments <- str_split(dom_bounds, ',')[[1]]
sum(
sapply(dom_fragments,
function(x) {as.integer(str_split(x, '-')[[1]][2]) -
as.integer(str_split(x, '-')[[1]][1]) + 1})
)
})
getwd()
domain_arch_dir <- '../../results/resolved_domain_architectures'
orthogroups_df <- read_csv('../../data/orthogroups.csv')
fam_to_clan <- make_pfam_clan_hashtables('../../data/Pfam-A-clans.tsv')
excluded_microsp <- readLines('../../data/excluded_species.txt')
essential_yeast_genes <- readLines('../../data/essential_yeast_genes.txt')
str_c(dirname(dirname(domain_arch_dir)),
'/resources/orthogroup_domain_archs.rds')
## Helper functions
make_pfam_clan_hashtables <- function(pfam_clans) {
# ---------------------------------------------------------------------------
# Docstring goes here.
# ---------------------------------------------------------------------------
file_name = pfam_clans
out <- str_c(dirname(dirname(file_name)),  # file to save this hashtable to
'/resources/pfam_fam_to_clan.rds')
if (file.exists(out)) {
return(readRDS(out))
}
pfam_clans <- read_tsv(pfam_clans, show_col_types = F)
# create hashtables mapping both pfam families back to their clans
fam_to_clan <- new.env()
Map(function(fam, clan) {fam_to_clan[[fam]] <- ifelse(is.na(clan), fam, clan)},
pfam_clans$Family_ID, pfam_clans$Clan_name)
# write hashtable to resources folder
saveRDS(fam_to_clan, out)
return(fam_to_clan)
}
# make hashtable mapping Pfam domain families back to their clans
fam_to_clan <- make_pfam_clan_hashtables(args[3])
fam_to_clan <- make_pfam_clan_hashtables('../../data/Pfam-A-clans.tsv')
fam_to_clan <- make_pfam_clan_hashtables('../../data/Pfam-A-clans.tsv')
if (file.exists(str_c(dirname(dirname(domain_arch_dir)),
'/resources/orthogroup_domain_archs.rds'))) {
orthogroup_domain_archs <-
readRDS(str_c(dirname(dirname(domain_arch_dir)),
'/resources/orthogroup_domain_archs.rds'))
} else {
orthogroup_domain_archs <- get_orthogroup_domain_arch_hash(domain_arch_dir,
fam_to_clan)
saveRDS(orthogroup_domain_archs,
str_c(dirname(dirname(domain_arch_dir)),
'/resources/orthogroup_domain_archs.rds'))
}
# align all pairs of single-copy orthologs with Needleman-Wunsch alignment
aligned_domain_archs <- assign_and_align_domain_archs(orthogroups_df,
orthogroup_domain_archs,
fam_to_clan,
essential_yeast_genes,
excluded_microsp)
view(aligned_domain_archs)
view(filter(aligned_domain_archs, ortholog_short_enough_for_dom_loss))
write_csv(aligned_domain_archs, '../../results/aligned_domain_archs.csv')
require(tidyverse)
require(svglite)
aligned_domain_archs <- read_csv('../../results/aligned_domain_archs.csv')
out_dir <- '../../results/domain_arch_conservation_plots'
################################################################################
# Helper functions
format_aligned_domain_archs_df <- function(aligned_domain_archs) {
# ----------------------------------------------------------------------------
# Docstring goes here.
# ----------------------------------------------------------------------------
return(
aligned_domain_archs %>%
# remove orthologs from microsporidia species w/ poor quality genomes
#
# also exclude cases of lost domain orthologs that are not short enough
# to have confidently lost their domains
filter(!exclude_species, is.na(ortholog_short_enough_for_dom_loss) |
ortholog_short_enough_for_dom_loss) %>%
# add columns indicating whether a particular microsporidia ortholog
# has undergone domain gain, swap and/or loss
# use these columns for domain arch conservation rates later
mutate(lost = as.integer(!is.na(lost_doms)),
gain = as.integer(!is.na(gained_doms)),
swap = as.integer(!is.na(swapped_doms)),
DA_conservation = get_DA_conservation(lost, gain, swap)) %>%
separate_rows(DA_conservation, sep = ',') %>%
mutate(essential = ifelse(essential, 'Essential', 'Non-essential'))
)
}
get_DA_conservation <- Vectorize(function(lost, gain, swap) {
# ----------------------------------------------------------------------------
# Docstring goes here.
# ----------------------------------------------------------------------------
changes <- c()
if (lost > 0) {
changes <- append(changes, 'Loss')
}
if (gain > 0) {
changes <- append(changes, 'Gain')
}
if (swap > 0) {
changes <- append(changes, 'Swap')
}
if (length(changes) == 0) {
return('Conserved')
}
return(str_c(changes, collapse = ','))
}, vectorize.args = c('lost', 'gain', 'swap'))
draw_DA_conservation_plot <- function(sp_df, sp_name, out_dir) {
# ---------------------------------------------------------------------------
# Docstring goes here.
# ---------------------------------------------------------------------------
# format sp_df for plotting, by summarising counts of domain arch change events
# across essential and non-essential ortholog pairs
num_ortholog_pairs <- nrow(sp_df)  # get this number before we transform the dataframe
sp_df <- sp_df %>%
group_by(DA_conservation, essential) %>%
summarise(n = n())
# plot and save in out_dir directory
plot <- ggplot(data = sp_df, aes(x = DA_conservation, y = n, fill = essential)) +
geom_bar(stat = 'identity') +
labs(x = 'Domain architecture similarity to yeast',
y = 'count',
title = str_c(sp_name, '\n',
str_c('n = ', num_ortholog_pairs, ' single-copy ortholog pairs'))) +
theme_bw() +
theme(legend.position = c(0.73, 0.85),
axis.title = element_text(size = 12, color = 'black'),
axis.text = element_text(size = 12, color = 'black'),
legend.text = element_text(size = 12),
legend.title = element_blank())
ggsave(str_c(out_dir, '/', sp_name, '.svg'),
plot=plot,
units='in',
dpi=600,
width=3.83,
height=3.91)
}
aligned_domain_archs <- format_aligned_domain_archs_df(aligned_domain_archs)
view(aligned_domain_archs)
format_aligned_domain_archs_df <- function(aligned_domain_archs) {
# ----------------------------------------------------------------------------
# Docstring goes here.
# ----------------------------------------------------------------------------
return(
aligned_domain_archs %>%
# remove orthologs from microsporidia species w/ poor quality genomes
#
# also exclude cases of lost domain orthologs that are not short enough
# to have confidently lost their domains
filter(!exclude_species, is.na(ortholog_short_enough_for_dom_loss) |
ortholog_short_enough_for_dom_loss) %>%
# add columns indicating whether a particular microsporidia ortholog
# has undergone domain gain, swap and/or loss
# use these columns for domain arch conservation rates later
mutate(lost = as.integer(!is.na(lost_doms)),
gain = as.integer(!is.na(gained_doms)),
swap = as.integer(!is.na(swapped_doms)),
DA_conservation = get_DA_conservation(lost, gain, swap)) %>%
separate_rows(DA_conservation, sep = ',') %>%
mutate(essential = ifelse(essential, 'Essential', 'Non-essential')) %>%
select(-lost, -gain, -swap)
)
}
aligned_domain_archs <- format_aligned_domain_archs_df(aligned_domain_archs)
view(aligned_domain_archs)
# split dataframe by species and plot domain arch conservation rates individually
# for each species
dir.create(out_dir)  # initialize the directory to write plots into
sp_domain_archs <- split(aligned_domain_archs, f=aligned_domain_archs$species)
Map(function(sp_df, sp_name) {draw_DA_conservation_plot(sp_df, sp_name,
out_dir)},
sp_domain_archs,
names(sp_domain_archs))
# draw plot of overall domain arch conservation rates for Microsporidia only
# TODO - maybe draw plots for each clade of microsporidia?
draw_DA_conservation_plot(filter(aligned_domain_archs, is_microsp,
species != 'R_allo'),
'All microsporidia', out_dir)
# draw plot of overall domain arch conservation rates for non-Microsporidia
draw_DA_conservation_plot(filter(aligned_domain_archs, !is_microsp),
'Outgroup species', out_dir)
draw_DA_conservation_plot(sp_domain_archs[['N_pari']], 'N_pari', out_dir)
dir.create(out_dir)  # initialize the directory to write plots into
draw_DA_conservation_plot(sp_domain_archs[['N_pari']], 'N_pari', out_dir)
sp_df <- sp_domain_archs[['N_pari']]
sp_name <- 'N_pari'
num_ortholog_pairs <- nrow(sp_df)  # get this number before we transform the dataframe
sp_df <- sp_df %>%
group_by(DA_conservation, essential) %>%
summarise(n = n())
view(sp_df)
sp_df <- sp_domain_archs[['N_pari']]
view(sp_df)
view(aligned_domain_archs)
aligned_domain_archs <- read_csv('../../results/aligned_domain_archs.csv')
view(aligned_domain_archs)
format_aligned_domain_archs_df <- function(aligned_domain_archs) {
# ----------------------------------------------------------------------------
# Docstring goes here.
# ----------------------------------------------------------------------------
return(
aligned_domain_archs %>%
# remove orthologs from microsporidia species w/ poor quality genomes
#
# also exclude cases of lost domain orthologs that are not short enough
# to have confidently lost their domains
filter(!exclude_species, is.na(ortholog_short_enough_for_dom_loss) |
ortholog_short_enough_for_dom_loss) %>%
# add columns indicating whether a particular microsporidia ortholog
# has undergone domain gain, swap and/or loss
# use these columns for domain arch conservation rates later
mutate(lost = as.integer(!is.na(lost_doms)),
gain = as.integer(!is.na(gained_doms)),
swap = as.integer(!is.na(swapped_doms)),
DA_conservation = get_DA_conservation(lost, gain, swap)) %>%
separate_rows(DA_conservation, sep = ',') %>%
select(-lost, -gain, -swap)
)
}
# genomes are excluded from the dataframe, all ortholog pairs are annotated with
# the essentiality of their yeast orthologs and
aligned_domain_archs <- format_aligned_domain_archs_df(aligned_domain_archs)
view(aligned_domain_archs)
rm(sp_df)
rm(sp_name)
sp_domain_archs <- split(aligned_domain_archs, f=aligned_domain_archs$species)
Map(function(sp_df, sp_name) {draw_DA_conservation_plot(sp_df, sp_name,
out_dir)},
sp_domain_archs,
names(sp_domain_archs))
# draw plot of overall domain arch conservation rates for Microsporidia only
# TODO - maybe draw plots for each clade of microsporidia?
draw_DA_conservation_plot(filter(aligned_domain_archs, is_microsp,
species != 'R_allo'),
'All microsporidia', out_dir)
# draw plot of overall domain arch conservation rates for non-Microsporidia
draw_DA_conservation_plot(filter(aligned_domain_archs, !is_microsp),
'Outgroup species', out_dir)
draw_DA_conservation_plot <- function(sp_df, sp_name, out_dir) {
# ---------------------------------------------------------------------------
# Docstring goes here.
# ---------------------------------------------------------------------------
# format sp_df for plotting, by summarising counts of domain arch change events
# across essential and non-essential ortholog pairs
num_ortholog_pairs <- nrow(sp_df)  # get this number before we transform the dataframe
sp_df <- sp_df %>%
group_by(DA_conservation, essential) %>%
summarise(n = n())
# plot and save in out_dir directory
plot <- ggplot(data = sp_df, aes(x = DA_conservation, y = n, fill = essential)) +
geom_bar(stat = 'identity') +
labs(x = 'Domain architecture similarity to yeast',
y = 'count',
title = str_c(sp_name, '\n',
str_c('n = ', num_ortholog_pairs, ' single-copy ortholog pairs'))) +
theme_bw() +
theme(legend.position = c(0.73, 0.85),
axis.title = element_text(size = 12, color = 'black'),
axis.text = element_text(size = 12, color = 'black'),
legend.text = element_text(size = 12))
ggsave(str_c(out_dir, '/', sp_name, '.svg'),
plot=plot,
units='in',
dpi=600,
width=3.83,
height=3.91)
}
dir.create(out_dir)  # initialize the directory to write plots into
sp_domain_archs <- split(aligned_domain_archs, f=aligned_domain_archs$species)
Map(function(sp_df, sp_name) {draw_DA_conservation_plot(sp_df, sp_name,
out_dir)},
sp_domain_archs,
names(sp_domain_archs))
# draw plot of overall domain arch conservation rates for Microsporidia only
# TODO - maybe draw plots for each clade of microsporidia?
draw_DA_conservation_plot(filter(aligned_domain_archs, is_microsp,
species != 'R_allo'),
'All microsporidia', out_dir)
# draw plot of overall domain arch conservation rates for non-Microsporidia
draw_DA_conservation_plot(filter(aligned_domain_archs, !is_microsp),
'Outgroup species', out_dir)
